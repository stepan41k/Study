-- Перед выполнением заданий убедитесь, что структура таблиц вашей базы данных соответствует структуре ниже
-- project (id, projectname, about, startdate, enddate, status, price, idcommand, project_type)
-- student (id, lastname, firstname, role, email, yearb, groupname, idcommand)
-- command (id, command)
-- task (id,task, idproject)
-- resource (id, resource, idproject)
-- grouplist (groupname, sp)
-- mentor (id, lastname, firstname, email, idcommand)

-- При выполнении задания создавайте отчет в виде sql-кода, включающего текст задания.

--         3.1. Методы контроля качества данных
--             3.1.1. Поиск с помощью регулярных выражений. Откройте ресурс Postgres Pro Standard : Документация: 9.5: 9.7. Поиск по шаблону : Компания Postgres Professional, почитайте применение функций работы с регулярными выражениями, напишите запросы с применением данных функций при обращении к данным из вашей базы данных:
--                 • выполните поиск с применением функции regexp_match;
                        SELECT regexp_match(projectname, 'П\w+') FROM project;
--                 • выполните поиск с применением функции regexp_matches;
                        SELECT regexp_matches(about, '\mр\w*', 'g') FROM project;
--                 • выполните поиск с применением regexp_replace;
                        SELECT regexp_replace(role, 'Студент', 'Ученик', 'g') FROM student;
--                 • разберитесь с функцией regexp_split_to_table;
                        SELECT regexp_split_to_table(about, '\s+') FROM project;
--                 • разберитесь с функцией split_part;
                        SELECT split_part(email, '@', 2) FROM student;
--                 • разберитесь с функцией substring;
                        SELECT substring(startdate::text FROM '^\d{4}') FROM project;
--                 • разберитесь с функцией regexp_substr.
                        SELECT regexp_substr(about, '\d{4}') FROM project;
--             3.1.2. Работа с регулярными выражениями
--                 • Напишите регулярное выражение для поиска HTML-цвета, заданного как #ABCDEF, то есть # и содержит затем 6 шестнадцатеричных символов
                        SELECT regexp_matches('Цвет фона: #ABCDEF, текст: #123456.', '#[0-9A-Fa-f]{6}', 'g');
--                 • Написать регулярное выражение для выбора IP адресов
                        SELECT regexp_matches('IP-адреса: 192.168.1.1 и 10.0.0.255.', '\m((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\M', 'g');
--                 • Напишите регулярное выражение, которое находит даты в строке. Дата должна быть в формате DD.MM.YYYY
                        SELECT regexp_matches('Даты: 31.12.2023, 01.01.2024.', '(0[1-9]|[12][0-9]|3[01])\.(0[1-9]|1[0-2])\.(19|20)\d{2}', 'g');
--                 •  Напишите регулярное выражение, которое находит цены в тексте. Цена может быть представлена в разных форматах: целое число, число с десятичными знаками, включать символ валюты, разделители.
                        SELECT regexp_matches('Цены: 100 руб., 12.50 USD, $50, 1,000,000.', '\$\d{1,3}(,\d{3})*(\.\d+)?|\d+(\.\d+)?\s?(руб\.|USD)?', 'g');
--             3.1.3. Работа с неструктурированными данными:
--                 • Создайте временную таблицу tempdata, в которой в одно поле сохраните Фамилия Имя, год рождения, категория, таких записей у вас должно быть несколько.
                        CREATE TEMP TABLE z5_tempdata (raw_data TEXT);

                        INSERT INTO z5_tempdata (raw_data) VALUES
                        ('Иванов Иван, 1999, Категория А'),
                        ('Петров-Сидоров Петр, 2001, Категория Б'),
                        ('Сергеева Анна-Мария, 2000'),
                        ('Сидорова Ольга, 2002, Категория В');
--                 • Произведите поиск по данным всех фамилий.
                        SELECT regexp_match(raw_data, '^\w+(-\w+)?') FROM tempdata;
--                 • Произведите поиск по данным всех годов рождений.
                        SELECT regexp_match(raw_data, '\d{4}') FROM tempdata;
--                 • Произведите поиск по данным всех категорий.
                        SELECT regexp_match(raw_data, 'Категория\s\w') FROM tempdata;
--                 • Разбейте неструктурированные данные и преобразуйте каждую строку с разделителями в строку таблицы student. 
-- При выполнении задания обратите внимание на применение регулярных выражений для извлечения данных их неструктурированных строк, обработка разных разделителей (пробел, запятая), обработка Null значений (возможное отсутствие значения поля категория) и исключений – двойная фамилия или имя, записанные через дефис.
                        INSERT INTO student (lastname, firstname, yearb)
                        SELECT
                            (regexp_match(raw_data, '^(\S+)\s'))[1],
                            (regexp_match(raw_data, '^\S+\s(\S+),'))[1],
                            (regexp_match(raw_data, '(\d{4})'))[1]::integer
                        FROM tempdata;
--                 • *воспользуйтесь методом работы с регулярными выражениями в сочетании с командой поиска по рекурсивным данным для решения задачи выше, применяя рекурсивный CTE для последовательной обработки каждого элемента данных.
                        WITH RECURSIVE parsed_data AS (
                            SELECT id, regexp_split_to_array(raw_data, ',\s*') as parts, 1 as n
                            FROM (SELECT row_number() over() as id, raw_data FROM tempdata) as t
                            UNION ALL
                            SELECT id, parts, n + 1
                            FROM parsed_data
                            WHERE n < array_length(parts, 1)
                        )
                        SELECT id, split_part(parts[1], ' ', 1) as lastname, split_part(parts[1], ' ', 2) as firstname, parts[2] as yearb, parts[3] as category
                        FROM parsed_data
                        WHERE n = 1;

--             3.1.4. Добавьте в таблицу project поле shifr, при создании используйте check проверку с применением регулярного выражения (первые две буквы латинские, потом четыре цифры). Заполните таблицу значениями.

--         3.2. Анализ статистики, создание индексов
--             3.2.1. Напишите инструкцию для просмотра статистики любой таблицы (по примеру )
--             3.2.2. Выведите значение поля  из предыдущего запроса
--             3.2.3. Выполните чтение таблицы
--             3.2.4. Проверьте значение поля  после чтения таблицы
--             3.2.5. Создайте таблицу stattable на основании запроса на нахождения количества вставленных строк, удалённых строк (из статистики).
--             3.2.6. Создайте индекс в таблице mentor – включающий поля lastname и name
--             3.2.7. Создайте индекс в таблице project, включающий поле категория (по убыванию значения).
--             3.2.8. Напишите запрос к таблице project с применением индекса по категории.
--             3.2.9. Найдите количество сканирований по индексу, количество строк, отобранных при сканированиях по индексу.

--         3.3. План выполнения запроса
--             3.3.1. Постройте план запроса для нахождения данных о проектах указанной команды с сортировкой по дате начала работы над проектом
--                 • EXPLAIN SQL-запрос
--             3.3.2. Просмотрите план запроса с применением F7 
--             3.3.3. Просмотрите анализ плана 
--             3.3.4. Просмотрите анализ плана запроса с применением 
--             3.3.5. Нарисуйте абстрактное синтаксическое дерево разбора вашего запроса
--             3.3.6. Нарисуйте дерево плана, какие узлы данного дерева? Что означают узлы дерева?
--             3.3.7. Создайте индекс в таблице student, включающий поле категория пользователя (по убыванию значения). Посмотрите план запроса с применением индекса.
--             3.3.8. Создайте копию таблицы student. Удалите первичный ключ с поля id в ней.
--             3.3.9. Запросите одного пользователя по его коду. Постройте план запроса, определите способ доступа.
--             3.3.10. Выберите всех студентов, которые в текущем году не выполнили ни одного проекта. Напишите два варианта запроса – через join и через подзапрос. Сравните планы исполнения этих запросов, сделайте выводы.
--             3.3.11. Выведите список студентов и название команд. С помощью hints добейтесь всех трех способов исполнения соединения.
--                 • Подсказка – указываем применить разные способы соединения

--         3.4. Расширенные запросы, курсоры
--             3.4.1. Создайте преподготовленный запрос для выполнения запроса: найдите год рождения студента с указанным номером.
--                 • Выполните запрос с разными значениями входного параметра.
--                 • Постройте план запросов, сравните стоимость запроса без применения преподготовленного запроса и с применением.
--             3.4.2. Создайте преподготовленный запрос на удаление записи в таблице Project. Стартуйте транзакцию (begin). Выполните запрос с разными параметрами. Откатите транзакцию (rollback).
--             3.4.3. Создайте курсор для выборки данных из таблицы Project указанной команды.  Используя оператор FETCH NEXT FROM курсор, переберите записи из курсора, закройте курсор CLOSE курсор.

--         3.5. Секционирование
--             3.5.1. Создание таблицы с разбиением по значению поля даты
--                 • Создайте секционированную таблицу secproject по диапазону дат начала работы над проектом (распределите по годам или по месяцам, в зависимости от данных вашей таблицы). Создайте три секции для разных временных периодов.
--                 • Напишите запрос на вставку записей из таблицы Project в созданную таблицу. 
--                 • Напишите запрос на выборку данных из каждой созданной секции, например, select * from Sec_Project partition_part1;
--                 • Удалите одну из секций
--             3.5.2. Создайте таблицу users с секционированием по диапазонам годов рождения, которая будет содержать данные студентов, распределенные по диапазонам годов рождения. Создайте секции для разных возрастных групп: студенты, родившиеся с 1998 по 2000, с 2001 по 2003 год, с 2004 по 2006 год. Проверьте распределение.

--         3.6. Наследование и правила*
--             3.6.1. Создайте таблицы-наследники по группам student3091, student3092, student3093.
--             3.6.2. Напишите правила для автоматического распределения студентов при вставке записей в таблицу student.
--             3.6.3. Протестируйте работу правил вставкой записей, проверьте полученный результат.